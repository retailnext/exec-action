{"version":3,"file":"index.js","sources":["../src/github-actions.ts","../src/main.ts","../src/index.ts"],"sourcesContent":["/**\n * Local implementations of GitHub Actions functions.\n * These replace the @actions/core dependency with zero external dependencies.\n */\n\nimport { appendFileSync } from 'fs'\n\n/**\n * Gets the value of an input. The value is retrieved from the environment\n * variable INPUT_<name> (converted to uppercase).\n *\n * @param name Name of the input to get\n * @param options Optional. If required is true, will throw if input is not set\n * @returns string\n */\nexport function getInput(\n  name: string,\n  options?: { required?: boolean }\n): string {\n  const envName = `INPUT_${name.replace(/ /g, '_').toUpperCase()}`\n  const val = process.env[envName] || ''\n\n  if (options?.required && !val) {\n    throw new Error(`Input required and not supplied: ${name}`)\n  }\n\n  return val.trim()\n}\n\n/**\n * Sets the value of an output by writing to the GITHUB_OUTPUT file.\n *\n * @param name Name of the output to set\n * @param value Value to set\n */\nexport function setOutput(name: string, value: string): void {\n  const outputFile = process.env['GITHUB_OUTPUT']\n  if (!outputFile) {\n    // In local development without GitHub Actions environment\n    return\n  }\n\n  // Format: name=value (with proper escaping for multiline values)\n  const delimiter = `ghadelimiter_${Math.random().toString(36).substring(2)}`\n  const output = `${name}<<${delimiter}\\n${value}\\n${delimiter}\\n`\n\n  appendFileSync(outputFile, output, { encoding: 'utf8' })\n}\n\n/**\n * Writes debug message to stdout using GitHub Actions workflow command format.\n *\n * @param message Debug message\n */\nexport function debug(message: string): void {\n  process.stdout.write(`::debug::${message}\\n`)\n}\n\n/**\n * Sets the action status to failed. Writes an error message and exits the process.\n *\n * @param message Error message\n */\nexport function setFailed(message: string): void {\n  process.exitCode = 1\n  process.stdout.write(`::error::${message}\\n`)\n}\n","import { spawn } from 'child_process'\nimport * as core from './github-actions.js'\n\n/**\n * The main function for the action.\n *\n * @returns Resolves when the action is complete.\n */\nexport async function run(): Promise<void> {\n  try {\n    const command: string = core.getInput('command', { required: true })\n    const successExitCodesInput: string = core.getInput('success_exit_codes')\n\n    core.debug(`Executing command: ${command}`)\n    core.debug(`Success exit codes: ${successExitCodesInput}`)\n\n    // Parse success exit codes\n    const successExitCodes = parseSuccessExitCodes(successExitCodesInput)\n\n    // Execute the command and capture outputs\n    const result = await executeCommand(command)\n\n    // Set outputs for other workflow steps to use\n    core.setOutput('stdout', result.stdout)\n    core.setOutput('stderr', result.stderr)\n    core.setOutput('exit_code', result.exitCode.toString())\n\n    // Check if the exit code should be treated as success\n    if (!successExitCodes.has(result.exitCode)) {\n      core.setFailed(\n        `Command exited with code ${result.exitCode}: ${result.stderr || result.stdout}`\n      )\n    }\n  } catch (error) {\n    // Fail the workflow run if an error occurs\n    if (error instanceof Error) core.setFailed(error.message)\n  }\n}\n\n/**\n * Parse the success exit codes input.\n * Supports individual codes (e.g., \"0,1,2\") and ranges (e.g., \"0-2,5,10-15\").\n *\n * @param input The success exit codes input string.\n * @returns A Set of exit codes that should be treated as success.\n */\nexport function parseSuccessExitCodes(input: string): Set<number> {\n  const exitCodes = new Set<number>()\n\n  if (!input || input.trim() === '') {\n    exitCodes.add(0)\n    return exitCodes\n  }\n\n  const parts = input.split(',').map((part) => part.trim())\n\n  for (const part of parts) {\n    if (part.includes('-')) {\n      // Parse range (e.g., \"0-2\")\n      const [startStr, endStr] = part.split('-').map((s) => s.trim())\n      const start = parseInt(startStr, 10)\n      const end = parseInt(endStr, 10)\n\n      if (isNaN(start) || isNaN(end)) {\n        throw new Error(\n          `Invalid range format: \"${part}\". Expected format: \"start-end\" (e.g., \"0-2\")`\n        )\n      }\n\n      if (start < 0 || end < 0) {\n        throw new Error(\n          `Invalid range: \"${part}\". Exit codes must be non-negative integers`\n        )\n      }\n\n      if (start > end) {\n        throw new Error(\n          `Invalid range: \"${part}\". Start (${start}) must be less than or equal to end (${end})`\n        )\n      }\n\n      for (let i = start; i <= end; i++) {\n        exitCodes.add(i)\n      }\n    } else {\n      // Parse individual code\n      const code = parseInt(part, 10)\n      if (isNaN(code)) {\n        throw new Error(\n          `Invalid exit code: \"${part}\". Expected a number or range (e.g., \"0\" or \"0-2\")`\n        )\n      }\n\n      if (code < 0) {\n        throw new Error(\n          `Invalid exit code: \"${part}\". Exit codes must be non-negative integers`\n        )\n      }\n\n      exitCodes.add(code)\n    }\n  }\n\n  return exitCodes\n}\n\n/**\n * Execute a command and capture its output.\n *\n * @param command The command to execute.\n * @returns A promise that resolves with stdout, stderr, and exit code.\n */\nexport async function executeCommand(command: string): Promise<{\n  stdout: string\n  stderr: string\n  exitCode: number\n}> {\n  return new Promise((resolve, reject) => {\n    // Parse command into executable and arguments\n    // Simple parsing that splits on whitespace while respecting quoted strings\n    const args = parseCommand(command)\n    if (args.length === 0) {\n      reject(new Error('Command cannot be empty'))\n      return\n    }\n\n    const executable = args[0]\n    const commandArgs = args.slice(1)\n\n    // Execute command directly without shell\n    const child = spawn(executable, commandArgs, {\n      stdio: ['inherit', 'pipe', 'pipe']\n    })\n\n    let stdout = ''\n    let stderr = ''\n    let settled = false\n\n    // Capture and stream stdout\n    if (child.stdout) {\n      child.stdout.on('data', (data: Buffer) => {\n        const text = data.toString()\n        stdout += text\n        process.stdout.write(text)\n      })\n    }\n\n    // Capture and stream stderr\n    if (child.stderr) {\n      child.stderr.on('data', (data: Buffer) => {\n        const text = data.toString()\n        stderr += text\n        process.stderr.write(text)\n      })\n    }\n\n    // Forward signals to the child process\n    const signals: NodeJS.Signals[] = [\n      'SIGINT',\n      'SIGTERM',\n      'SIGQUIT',\n      'SIGHUP',\n      'SIGPIPE',\n      'SIGABRT'\n    ]\n\n    // Create individual signal handlers for proper cleanup\n    const signalHandlers = new Map<NodeJS.Signals, () => void>()\n    for (const signal of signals) {\n      const handler = () => {\n        core.debug(`Received ${signal}, forwarding to child process`)\n        child.kill(signal)\n      }\n      signalHandlers.set(signal, handler)\n      process.on(signal, handler)\n    }\n\n    // Clean up signal handlers when child closes\n    const cleanupSignalHandlers = () => {\n      for (const [signal, handler] of signalHandlers) {\n        process.removeListener(signal, handler)\n      }\n      signalHandlers.clear()\n    }\n\n    // Handle errors (e.g., command not found)\n    child.on('error', (error: Error) => {\n      if (!settled) {\n        settled = true\n        cleanupSignalHandlers()\n        reject(error)\n      }\n    })\n\n    // Handle process exit\n    child.on('close', (code: number | null) => {\n      if (!settled) {\n        settled = true\n        cleanupSignalHandlers()\n        resolve({\n          stdout,\n          stderr,\n          exitCode: code ?? 0\n        })\n      }\n    })\n  })\n}\n\n/**\n * Parse a command string into an array of arguments.\n * Handles quoted strings and escapes.\n *\n * @param command The command string to parse.\n * @returns An array of arguments.\n */\nexport function parseCommand(command: string): string[] {\n  const args: string[] = []\n  let current = ''\n  let inQuotes: string | null = null\n  let escaped = false\n\n  for (let i = 0; i < command.length; i++) {\n    const char = command[i]\n\n    if (escaped) {\n      current += char\n      escaped = false\n      continue\n    }\n\n    if (char === '\\\\') {\n      escaped = true\n      continue\n    }\n\n    if (inQuotes) {\n      if (char === inQuotes) {\n        inQuotes = null\n      } else {\n        current += char\n      }\n    } else if (char === '\"' || char === \"'\") {\n      inQuotes = char\n    } else if (char === ' ' || char === '\\t' || char === '\\n') {\n      if (current.length > 0) {\n        args.push(current)\n        current = ''\n      }\n    } else {\n      current += char\n    }\n  }\n\n  // Handle edge cases\n  if (escaped) {\n    throw new Error('Invalid command: ends with an incomplete escape sequence')\n  }\n\n  if (inQuotes) {\n    throw new Error(`Invalid command: unclosed quote (${inQuotes})`)\n  }\n\n  if (current.length > 0) {\n    args.push(current)\n  }\n\n  return args\n}\n","/**\n * The entrypoint for the action. This file simply imports and runs the action's\n * main logic.\n */\nimport { run } from './main.js'\n\n/* istanbul ignore next */\nrun()\n"],"names":["core.getInput","core.debug","core.setOutput","core.setFailed"],"mappings":"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"}