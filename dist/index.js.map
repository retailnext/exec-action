{"version":3,"file":"index.js","sources":["../src/github-actions.ts","../src/main.ts","../src/index.ts"],"sourcesContent":["/**\n * Local implementations of GitHub Actions functions.\n * These replace the @actions/core dependency with zero external dependencies.\n */\n\nimport { appendFileSync } from 'fs'\n\n/**\n * Gets the value of an input. The value is retrieved from the environment\n * variable INPUT_<name> (converted to uppercase).\n *\n * @param name Name of the input to get\n * @param options Optional. If required is true, will throw if input is not set\n * @returns string\n */\nexport function getInput(\n  name: string,\n  options?: { required?: boolean }\n): string {\n  const envName = `INPUT_${name.replace(/ /g, '_').toUpperCase()}`\n  const val = process.env[envName] || ''\n\n  if (options?.required && !val) {\n    throw new Error(`Input required and not supplied: ${name}`)\n  }\n\n  return val.trim()\n}\n\n/**\n * Sets the value of an output by writing to the GITHUB_OUTPUT file.\n *\n * @param name Name of the output to set\n * @param value Value to set\n */\nexport function setOutput(name: string, value: string): void {\n  const outputFile = process.env['GITHUB_OUTPUT']\n  if (!outputFile) {\n    // In local development without GitHub Actions environment\n    return\n  }\n\n  // Format: name=value (with proper escaping for multiline values)\n  // Use timestamp + random to ensure uniqueness\n  const delimiter = `ghadelimiter_${Date.now()}_${Math.random().toString(36).substring(2)}`\n  const output = `${name}<<${delimiter}\\n${value}\\n${delimiter}\\n`\n\n  appendFileSync(outputFile, output, { encoding: 'utf8' })\n}\n\n/**\n * Writes debug message to stdout using GitHub Actions workflow command format.\n *\n * @param message Debug message\n */\nexport function debug(message: string): void {\n  process.stdout.write(`::debug::${message}\\n`)\n}\n\n/**\n * Sets the action status to failed. Writes an error message and exits the process.\n *\n * @param message Error message\n */\nexport function setFailed(message: string): void {\n  process.exitCode = 1\n  process.stdout.write(`::error::${message}\\n`)\n}\n","import { spawn, execSync } from 'child_process'\nimport { tmpdir } from 'os'\nimport { join } from 'path'\nimport { unlinkSync, createReadStream, openSync, closeSync } from 'fs'\nimport * as core from './github-actions.js'\n\n/**\n * The main function for the action.\n *\n * @returns Resolves when the action is complete.\n */\nexport async function run(): Promise<void> {\n  try {\n    const command: string = core.getInput('command', { required: true })\n    const successExitCodesInput: string = core.getInput('success_exit_codes')\n    const separateOutputsInput: string = core.getInput('separate_outputs')\n\n    core.debug(`Executing command: ${command}`)\n    core.debug(`Success exit codes: ${successExitCodesInput}`)\n    core.debug(`Separate outputs: ${separateOutputsInput}`)\n\n    // Parse inputs\n    const successExitCodes = parseSuccessExitCodes(successExitCodesInput)\n    // Default to false (combined outputs)\n    const separateOutputs =\n      separateOutputsInput.toLowerCase() === 'true' ||\n      separateOutputsInput === '1'\n\n    // Execute the command and capture outputs\n    const result = await executeCommand(command, separateOutputs)\n\n    // Set outputs based on separate_outputs flag\n    if (separateOutputs) {\n      core.setOutput('stdout', result.stdout)\n      core.setOutput('stderr', result.stderr)\n    } else {\n      core.setOutput('combined_output', result.combinedOutput)\n    }\n    core.setOutput('exit_code', result.exitCode.toString())\n\n    // Check if the exit code should be treated as success\n    if (!successExitCodes.has(result.exitCode)) {\n      const errorOutput = separateOutputs\n        ? result.stderr || result.stdout\n        : result.combinedOutput\n      core.setFailed(\n        `Command exited with code ${result.exitCode}: ${errorOutput}`\n      )\n    }\n  } catch (error) {\n    // Fail the workflow run if an error occurs\n    if (error instanceof Error) core.setFailed(error.message)\n  }\n}\n\n/**\n * Parse the success exit codes input.\n * Supports individual codes (e.g., \"0,1,2\") and ranges (e.g., \"0-2,5,10-15\").\n *\n * @param input The success exit codes input string.\n * @returns A Set of exit codes that should be treated as success.\n */\nexport function parseSuccessExitCodes(input: string): Set<number> {\n  const exitCodes = new Set<number>()\n\n  if (!input || input.trim() === '') {\n    exitCodes.add(0)\n    return exitCodes\n  }\n\n  const parts = input.split(',').map((part) => part.trim())\n\n  for (const part of parts) {\n    if (part.includes('-')) {\n      // Parse range (e.g., \"0-2\")\n      const [startStr, endStr] = part.split('-').map((s) => s.trim())\n      const start = parseInt(startStr, 10)\n      const end = parseInt(endStr, 10)\n\n      if (isNaN(start) || isNaN(end)) {\n        throw new Error(\n          `Invalid range format: \"${part}\". Expected format: \"start-end\" (e.g., \"0-2\")`\n        )\n      }\n\n      if (start < 0 || end < 0) {\n        throw new Error(\n          `Invalid range: \"${part}\". Exit codes must be non-negative integers`\n        )\n      }\n\n      if (start > end) {\n        throw new Error(\n          `Invalid range: \"${part}\". Start (${start}) must be less than or equal to end (${end})`\n        )\n      }\n\n      for (let i = start; i <= end; i++) {\n        exitCodes.add(i)\n      }\n    } else {\n      // Parse individual code\n      const code = parseInt(part, 10)\n      if (isNaN(code)) {\n        throw new Error(\n          `Invalid exit code: \"${part}\". Expected a number or range (e.g., \"0\" or \"0-2\")`\n        )\n      }\n\n      if (code < 0) {\n        throw new Error(\n          `Invalid exit code: \"${part}\". Exit codes must be non-negative integers`\n        )\n      }\n\n      exitCodes.add(code)\n    }\n  }\n\n  return exitCodes\n}\n\n/**\n * Execute a command and capture its output.\n *\n * @param command The command to execute.\n * @param separateOutputs Whether to capture stdout and stderr separately.\n * @returns A promise that resolves with stdout, stderr, combinedOutput, and exit code.\n */\nexport async function executeCommand(\n  command: string,\n  separateOutputs: boolean = false\n): Promise<{\n  stdout: string\n  stderr: string\n  combinedOutput: string\n  exitCode: number\n}> {\n  return new Promise((resolve, reject) => {\n    // Parse command into executable and arguments\n    const args = parseCommand(command)\n    if (args.length === 0) {\n      reject(new Error('Command cannot be empty'))\n      return\n    }\n\n    const executable = args[0]\n    const commandArgs = args.slice(1)\n\n    let stdout = ''\n    let stderr = ''\n    let combinedOutput = ''\n    let settled = false\n\n    if (separateOutputs) {\n      // Separate mode: use two different pipes for stdout and stderr\n      const child = spawn(executable, commandArgs, {\n        stdio: ['inherit', 'pipe', 'pipe']\n      })\n\n      // Capture and stream stdout\n      if (child.stdout) {\n        child.stdout.on('data', (data: Buffer) => {\n          const text = data.toString()\n          stdout += text\n          process.stdout.write(text)\n        })\n      }\n\n      // Capture and stream stderr\n      if (child.stderr) {\n        child.stderr.on('data', (data: Buffer) => {\n          const text = data.toString()\n          stderr += text\n          process.stderr.write(text)\n        })\n      }\n\n      // Register error handler BEFORE setupSignalHandlers to avoid race condition\n      // where setupSignalHandlers' error handler resolves instead of rejecting\n      child.on('error', (error: Error) => {\n        if (!settled) {\n          settled = true\n          reject(error)\n        }\n      })\n\n      child.on('close', (code: number | null) => {\n        if (!settled) {\n          settled = true\n          resolve({\n            stdout,\n            stderr,\n            combinedOutput,\n            exitCode: code ?? 0\n          })\n        }\n      })\n\n      // Forward signals and handle process lifecycle\n      // This is registered AFTER error/close handlers to ensure proper event ordering\n      setupSignalHandlers(child, () => {\n        if (!settled) {\n          settled = true\n          resolve({\n            stdout,\n            stderr,\n            combinedOutput,\n            exitCode: 0\n          })\n        }\n      })\n    } else {\n      // Combined mode: create a FIFO (named pipe) and pass it to both stdout and stderr\n      // Note: Node.js doesn't expose pipe() syscall for anonymous pipes,\n      // so we use mkfifo to create a named pipe which provides the same behavior\n      const fifoPath = join(\n        tmpdir(),\n        `exec-action-${Date.now()}-${Math.random().toString(36).slice(2)}.fifo`\n      )\n\n      let fifoUnlinked = false\n\n      core.debug(`[FIFO] Creating FIFO at ${fifoPath}`)\n\n      try {\n        // Create a FIFO (named pipe)\n        execSync(`mkfifo \"${fifoPath}\"`)\n        core.debug('[FIFO] FIFO created successfully')\n\n        // Track if reader has ended\n        let readerEnded = false\n\n        // Open the FIFO for reading (non-blocking)\n        core.debug('[FIFO] Opening reader')\n        const reader = createReadStream(fifoPath, { flags: 'r' })\n        core.debug('[FIFO] Reader opened')\n\n        reader.on('data', (data: Buffer) => {\n          const text = data.toString()\n          core.debug(`[FIFO] Received data: ${text.length} bytes`)\n          combinedOutput += text\n          core.debug(\n            `[FIFO] combinedOutput is now: ${combinedOutput.length} bytes`\n          )\n          process.stdout.write(text)\n        })\n\n        reader.on('end', () => {\n          core.debug('[FIFO] Reader ended')\n          readerEnded = true\n        })\n\n        reader.on('error', (error: Error) => {\n          core.debug(`[FIFO] Reader error: ${error.message}`)\n          if (!settled) {\n            settled = true\n            reader.destroy()\n            // FIFO will be either already unlinked or cleaned up by outer catch\n            reject(error)\n          }\n        })\n\n        // Open the FIFO for writing after a small delay to ensure reader is ready\n        // This prevents the open call from blocking\n        core.debug('[FIFO] Scheduling writer open in 50ms')\n        setTimeout(() => {\n          let writeFd: number | null = null\n\n          try {\n            core.debug('[FIFO] Opening writer')\n            writeFd = openSync(fifoPath, 'w')\n            core.debug(`[FIFO] Writer opened with fd ${writeFd}`)\n\n            // Unlink the FIFO immediately after both ends are open\n            // The file descriptors will continue to work until closed\n            // This is the ONLY place where the FIFO is unlinked - errors are not caught\n            core.debug('[FIFO] Unlinking FIFO')\n            unlinkSync(fifoPath)\n            fifoUnlinked = true\n            core.debug('[FIFO] FIFO unlinked')\n\n            // Spawn with the same fd for both stdout and stderr\n            core.debug(\n              `[FIFO] Spawning child: ${executable} ${commandArgs.join(' ')}`\n            )\n            const child = spawn(executable, commandArgs, {\n              stdio: ['inherit', writeFd, writeFd]\n            })\n            core.debug(`[FIFO] Child spawned with PID ${child.pid}`)\n\n            // Set up signal handlers\n            setupSignalHandlers(child, () => {\n              // Signal handler cleanup - only close write fd\n              // Don't destroy reader here - let the main close handler do it\n              if (writeFd !== null) {\n                try {\n                  closeSync(writeFd)\n                  writeFd = null\n                } catch (err) {\n                  core.debug(\n                    `[FIFO] Error closing write fd in signal cleanup: ${err}`\n                  )\n                }\n              }\n            })\n\n            child.on('error', (error: Error) => {\n              core.debug(`[FIFO] Child error: ${error.message}`)\n              if (!settled) {\n                settled = true\n                if (writeFd !== null) {\n                  try {\n                    closeSync(writeFd)\n                  } catch {\n                    // Ignore close errors\n                  }\n                }\n                reader.destroy()\n                reject(error)\n              }\n            })\n\n            child.on('close', (code: number | null) => {\n              core.debug(`[FIFO] Child closed with code ${code}`)\n              if (!settled) {\n                settled = true\n\n                // Close the write fd first\n                if (writeFd !== null) {\n                  try {\n                    core.debug('[FIFO] Closing write fd')\n                    closeSync(writeFd)\n                    writeFd = null\n                    core.debug('[FIFO] Write fd closed')\n                  } catch (err) {\n                    core.debug(`[FIFO] Error closing write fd: ${err}`)\n                  }\n                }\n\n                // Function to finalize and resolve\n                const finalize = () => {\n                  core.debug('[FIFO] Finalizing')\n                  core.debug(\n                    `[FIFO] Combined output length: ${combinedOutput.length}`\n                  )\n                  reader.destroy()\n                  core.debug('[FIFO] Resolving with output')\n                  resolve({\n                    stdout,\n                    stderr,\n                    combinedOutput,\n                    exitCode: code ?? 0\n                  })\n                }\n\n                // Wait for reader to end naturally, or timeout after 200ms\n                core.debug(`[FIFO] Reader ended status: ${readerEnded}`)\n                if (readerEnded) {\n                  finalize()\n                } else {\n                  core.debug('[FIFO] Waiting for reader to end...')\n                  let waited = 0\n                  const checkInterval = setInterval(() => {\n                    waited += 10\n                    if (readerEnded) {\n                      core.debug(`[FIFO] Reader ended after ${waited}ms`)\n                      clearInterval(checkInterval)\n                      finalize()\n                    } else if (waited >= 200) {\n                      core.debug(\n                        `[FIFO] Reader did not end after ${waited}ms, finalizing anyway`\n                      )\n                      clearInterval(checkInterval)\n                      finalize()\n                    }\n                  }, 10)\n                }\n              }\n            })\n          } catch (error) {\n            core.debug(`[FIFO] Error in setTimeout: ${error}`)\n            if (!settled) {\n              settled = true\n              if (writeFd !== null) {\n                try {\n                  closeSync(writeFd)\n                } catch (err) {\n                  core.debug(`[FIFO] Error closing write fd in catch: ${err}`)\n                }\n              }\n              reader.destroy()\n              // FIFO already unlinked\n              reject(error instanceof Error ? error : new Error(String(error)))\n            }\n          }\n        }, 50)\n      } catch (error) {\n        core.debug(`[FIFO] Error in outer try: ${error}`)\n        if (!settled) {\n          settled = true\n          // Clean up FIFO only if it wasn't successfully unlinked\n          if (!fifoUnlinked) {\n            unlinkSync(fifoPath)\n          }\n          reject(\n            error instanceof Error\n              ? error\n              : new Error(`Failed to create FIFO: ${error}`)\n          )\n        }\n      }\n    }\n  })\n}\n\n/**\n * Set up signal forwarding for a child process.\n *\n * @param child The child process to forward signals to.\n * @param cleanup Cleanup function to call when removing handlers.\n */\nfunction setupSignalHandlers(\n  child: ReturnType<typeof spawn>,\n  cleanup: () => void\n): void {\n  const signals: NodeJS.Signals[] = [\n    'SIGINT',\n    'SIGTERM',\n    'SIGQUIT',\n    'SIGHUP',\n    'SIGPIPE',\n    'SIGABRT'\n  ]\n\n  const signalHandlers = new Map<NodeJS.Signals, () => void>()\n  for (const signal of signals) {\n    const handler = () => {\n      core.debug(`Received ${signal}, forwarding to child process`)\n      child.kill(signal)\n    }\n    signalHandlers.set(signal, handler)\n    process.on(signal, handler)\n  }\n\n  // Clean up signal handlers when child closes\n  const cleanupSignalHandlers = () => {\n    for (const [signal, handler] of signalHandlers) {\n      process.removeListener(signal, handler)\n    }\n    signalHandlers.clear()\n    cleanup()\n  }\n\n  child.on('close', cleanupSignalHandlers)\n  child.on('error', cleanupSignalHandlers)\n}\n\n/**\n * Parse a command string into an array of arguments.\n * Handles quoted strings and escapes.\n *\n * @param command The command string to parse.\n * @returns An array of arguments.\n */\nexport function parseCommand(command: string): string[] {\n  const args: string[] = []\n  let current = ''\n  let inQuotes: string | null = null\n  let escaped = false\n\n  for (let i = 0; i < command.length; i++) {\n    const char = command[i]\n\n    if (escaped) {\n      current += char\n      escaped = false\n      continue\n    }\n\n    if (char === '\\\\') {\n      escaped = true\n      continue\n    }\n\n    if (inQuotes) {\n      if (char === inQuotes) {\n        inQuotes = null\n      } else {\n        current += char\n      }\n    } else if (char === '\"' || char === \"'\") {\n      inQuotes = char\n    } else if (char === ' ' || char === '\\t' || char === '\\n') {\n      if (current.length > 0) {\n        args.push(current)\n        current = ''\n      }\n    } else {\n      current += char\n    }\n  }\n\n  // Handle edge cases\n  if (escaped) {\n    throw new Error('Invalid command: ends with an incomplete escape sequence')\n  }\n\n  if (inQuotes) {\n    throw new Error(`Invalid command: unclosed quote (${inQuotes})`)\n  }\n\n  if (current.length > 0) {\n    args.push(current)\n  }\n\n  return args\n}\n","/**\n * The entrypoint for the action. This file simply imports and runs the action's\n * main logic.\n */\nimport { run } from './main.js'\n\n/* istanbul ignore next */\nrun()\n"],"names":["core.getInput","core.debug","core.setOutput","core.setFailed"],"mappings":"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"}